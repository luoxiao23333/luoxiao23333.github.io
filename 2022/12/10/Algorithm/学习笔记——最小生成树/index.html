<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>学习笔记——最小生成树 | Always on the way</title><meta name="author" content="Xiao Luo.,luo.1632@osu.edu"><meta name="copyright" content="Xiao Luo."><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@[toc] 简介规定点的数量为V，边为E生成树是指在连通图中包含所有节点的一棵树，即该树包含所有节点的同时每个节点的入度出度均为1。而一幅图的生成树有很多种，其中最小生成树指的是带权图的生成树中边权和最小的树。并且若图中的边权都不相同，则最小生成树唯一（每两个节点都只有一条边相连，每次选最小的），反之，就不一定了。最小生成树一般有两个通用的算法，一个是Prim算法，一个是Kruskal算法。 P">
<meta property="og:type" content="article">
<meta property="og:title" content="学习笔记——最小生成树">
<meta property="og:url" content="http://example.com/2022/12/10/Algorithm/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/index.html">
<meta property="og:site_name" content="Always on the way">
<meta property="og:description" content="@[toc] 简介规定点的数量为V，边为E生成树是指在连通图中包含所有节点的一棵树，即该树包含所有节点的同时每个节点的入度出度均为1。而一幅图的生成树有很多种，其中最小生成树指的是带权图的生成树中边权和最小的树。并且若图中的边权都不相同，则最小生成树唯一（每两个节点都只有一条边相连，每次选最小的），反之，就不一定了。最小生成树一般有两个通用的算法，一个是Prim算法，一个是Kruskal算法。 P">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/68.jpeg">
<meta property="article:published_time" content="2022-12-11T02:03:25.000Z">
<meta property="article:modified_time" content="2025-12-28T03:34:06.380Z">
<meta property="article:author" content="Xiao Luo.">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/68.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/10/Algorithm/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习笔记——最小生成树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-12-27 22:34:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> Algorithmic Problem Solving</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-sticky-note"></i><span> Post</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/68.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Always on the way</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> Algorithmic Problem Solving</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-sticky-note"></i><span> Post</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学习笔记——最小生成树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-11T02:03:25.000Z" title="Created 2022-12-10 21:03:25">2022-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-12-28T03:34:06.380Z" title="Updated 2025-12-27 22:34:06">2025-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>@[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>规定点的数量为V，边为E</strong><br>生成树是指在连通图中包含所有节点的一棵树，即该树包含所有节点的同时每个节点的入度出度均为1。而一幅图的生成树有很多种，其中最小生成树指的是带权图的生成树中边权和最小的树。并且若图中的边权都不相同，则最小生成树唯一（每两个节点都只有一条边相连，每次选最小的），反之，就不一定了。<br>最小生成树一般有两个通用的算法，一个是Prim算法，一个是Kruskal算法。</p>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim算法被形象的描述为一棵小树逐渐长大。首先，先从图中任意选取一个节点，寻找离该节点最近的节点合并形成一棵树，再更新各个相连节点到该树的距离，再找最小，合并直到长成节点树为V的树，即为最小生成树。<br>那在向树添加节点的过程中，怎样更新各节点到树的距离呢？首先，我们可以先定义一个优先队列（一种每次key值最大/最小的元素都在队首的数据结构），每次取结点时，将该节点所有邻接节点都丢入队列（未直接相连的先不管，因为只要是和树未直接相连的节点距离一定小于直接相连的），然后每次从队首中取出一个（距离最子树小的）节点，再更新直到树上有V个节点任务就完成了。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>若采用邻接链表存图，优先队列（一种二叉堆）每次插入都需要$log<em>{2}V$次操作，而一共入队$V$次所以时间复杂度为$O(Vlog</em>{2}V)$</p>
<h3 id="Q1最短网络"><a href="#Q1最短网络" class="headerlink" title="Q1最短网络"></a>Q1最短网络</h3><p>原题传送门_&gt;<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P1546">洛谷P1546</a><br>整个网络就是一张图，光纤的最小长度就是最小生成树的边权和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a&gt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX ((int)1e9)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">twice</span> &#123;</span><br><span class="line">    <span class="type">int</span> point, weight;<span class="comment">//邻接点和边权</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;twice&gt; node[<span class="number">101</span>];<span class="comment">//采用邻接链表</span></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">101</span>];<span class="comment">//标记是否已加入树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    <span class="type">int</span> dis, id;<span class="comment">//距离和点编号</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> point&amp;r)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; r.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, edge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">            &#123;</span><br><span class="line">                node[i].<span class="built_in">push_back</span>(&#123; j,x &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    priority_queue&lt;point&gt; Q;<span class="comment">//优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : node[<span class="number">1</span>])<span class="comment">//从1号节点开始建树</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(&#123; e.weight,e.point &#125;);<span class="comment">//将所有邻接点放入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//标记</span></span><br><span class="line">    <span class="keyword">while</span> (edge != n - <span class="number">1</span>)<span class="comment">//直到有n-1条边时树有n个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        point now = Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();<span class="comment">//弹出距离最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (vis[now.id])<span class="keyword">continue</span>;<span class="comment">//如果已在树内就跳过</span></span><br><span class="line">        vis[now.id] = <span class="literal">true</span>;<span class="comment">//标记一下</span></span><br><span class="line">        edge++;</span><br><span class="line">        ans += now.dis;<span class="comment">//答案更新，加上入树的边权</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : node[now.id])<span class="comment">//枚举所有邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.point])</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123; e.weight,e.point &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>除了Prime算法1，还有Kruskal可以求最小生成树。Kruskal算法是一种贪心思想，首先先将边权排序，将边权最小的边的两个节点放入同一个集合，然后看第二小的边，如果改边的两个点再同一集合内，就跳过改边，否则就继续，直到合并了$V-1$条边。这里点的集合操作采用<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42971794/article/details/87748390">并查集</a>的方式。<br>还是以Q1作为例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, val;<span class="comment">//边类，包含两个节点和权重</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">twice</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge;<span class="comment">//边集</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">    f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">            &#123;</span><br><span class="line">                edge.<span class="built_in">push_back</span>(&#123; i,j,x &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge .<span class="built_in">begin</span>(), edge .<span class="built_in">end</span>(), [](Edge&amp;l, Edge&amp;r)<span class="comment">//边权排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l.val &lt; r.val;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge.<span class="built_in">size</span>(); i++)<span class="comment">//从小到大</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(edge[i].from) == <span class="built_in">find</span>(edge[i].to))<span class="keyword">continue</span>; <span class="comment">//如果在同一集合</span></span><br><span class="line">        <span class="comment">//内就continue</span></span><br><span class="line">        ans += edge[i].val;<span class="comment">//答案更新</span></span><br><span class="line">        f[<span class="built_in">find</span>(edge[i].from)] = edge[i].to;<span class="comment">//将两个点加入同一集合</span></span><br><span class="line">        cnt++;<span class="comment">//边数加一</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;<span class="comment">//边数达到n-1就退出</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>并查集每次操作复杂度$log<em>{2}V$，一共循环E次，而排序E条边时$O(Elog</em>{2}E)$，所以复杂度$O(Elog_{2}E)$</p>
<h2 id="二者取舍"><a href="#二者取舍" class="headerlink" title="二者取舍"></a>二者取舍</h2><p>因为Prim算法以点为单位，所以适合对付稠密图，而Kruskal算法对付稀疏图。</p>
<h3 id="Q2公路修建"><a href="#Q2公路修建" class="headerlink" title="Q2公路修建"></a>Q2公路修建</h3><p>原题传送门-&gt;<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P1265">洛谷P1265</a><br>条件（1）保证了图里没有重边<br>条件（2）每次选路都只会选最近的城市修路，如果真有环，比如题设A离B最近，B离C最近，C离A最近，这不可能，<del>除非有虫洞</del> 可以手动模拟。<br>那就变成每次各个城市都选最近的城市修路，合并，修路，合并，而且每两个城市都只有一条路相连，着不就是<strong>Prime</strong>的实现过程。所以，这里我采用了Prime。滑稽.jpg<br>首先暴力存图，算出各个城市的距离，然后存图，然后收获了可爱的<strong>MLE</strong><br>60分code</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a&gt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX ((int)1e9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIS(x1,y1,x2,y2) (sqrt(pf(x1-x2)+pf(y1-y2)))<span class="comment">//距离</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">twice</span> &#123;</span><br><span class="line">    <span class="type">int</span> point;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;twice&gt; node[<span class="number">5001</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">5001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    <span class="type">double</span> dis;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> point&amp;r)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; r.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;  loc[<span class="number">5001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        cin &gt;&gt; loc[i].first &gt;&gt; loc[i].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">            &#123;</span><br><span class="line">                node[i].<span class="built_in">push_back</span>(&#123; j,<span class="built_in">DIS</span>(loc[i].first,loc[i].second,loc[j].first,loc[j].second) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> edge = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;point&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : node[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(&#123; e.weight,e.point &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (edge != p - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        point now = Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[now.id])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now.id] = <span class="literal">true</span>;</span><br><span class="line">        edge++;</span><br><span class="line">        ans += now.dis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : node[now.id])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.point])</span><br><span class="line">            &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123; e.weight,e.point &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; fixed;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码和上一道题操作一样，没啥好说的。<br>既然空间暴了，那咋办呢，我们发现,<del>看了某dalao提示</del>,距离只有距离更新和选节点时才用到，<del>所以Kruskal死了</del> ，只要入队时再计算距离即可。毕竟5000的数据$O(n^{2})$的时间复杂度完全过得了，就不用堆了。<br>ACcode</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a&gt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX ((int)1e9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIS(x1,y1,x2,y2) (sqrt(pf(x1-x2)+pf(y1-y2)))</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; node[<span class="number">5001</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">5001</span>];</span><br><span class="line"><span class="type">double</span> dis[<span class="number">5001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;  loc[<span class="number">5001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        cin &gt;&gt; loc[i].first &gt;&gt; loc[i].second;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> edge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        dis[i] = MAX;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0.</span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (edge != p - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        edge++;</span><br><span class="line">        <span class="type">double</span> minn = MAX;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[i] = <span class="built_in">min</span>(dis[i], <span class="built_in">DIS</span>(loc[i].first, loc[i].second, loc[now].first, loc[now].second));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]&amp;&amp;minn&gt;=dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                id = i;</span><br><span class="line">                minn = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        now = id;</span><br><span class="line">        ans += minn;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; fixed;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Q3-Slim-Span（苗条生成树）"><a href="#Q3-Slim-Span（苗条生成树）" class="headerlink" title="Q3 Slim Span（苗条生成树）"></a>Q3 Slim Span（苗条生成树）</h3><p><a target="_blank" rel="noopener" href="https://onlinejudge.org/external/13/p1395.pdf">题目pdf</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem">题目链接</a><br><img src="https://img-blog.csdnimg.cn/20191228031127759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTcxNzk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>题意简述<br>求所有生成树中最大边权与最小边权差最小的，输出它们的差值。<br>输入：<br>输入文件包含多组测试数据，每组测试数据如下： 第1行：2个整数n m （2 ≤ n ≤ 100 and 0 ≤ m ≤ n(n − 1)/2），n表示顶点数，m表示边数。接下来m行，每行3个空格分开的整数a b w（1 ≤ w ≤ 10000） , 表示顶点a与顶点b之间有一条边，权值为w。<br>输出：<br>对每组测试数据，如果图存在生成树，输出生成树的差值最小的；否则，输出-1。</p>
</blockquote>
<p>将边权排序，一共有$|E|$条边，设排好序的边集合为$A={e<em>1,e_2,\cdots ,e</em>{|E|} }$,那对于任意的$i,j,1\leq i \leq j \leq |E|$，对于$A$的子集合$S<em>{ij}={e_i,e</em>{i+1},\cdots ,e<em>j}$,$S</em>{i,j}$若能生成原图的生成树，则由$S_{i,j}$所生成的最小生成树的苗条度$\leq {e_j-e_i}$。所以将$i,j$做一个全排列，枚举每一对$i,j$组合即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">2000000000</span>;</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to, val;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">(<span class="type">int</span>&amp; f, <span class="type">int</span>&amp; t, <span class="type">int</span>&amp; v)</span> :from(f), to(t), val(v) &#123;</span>  &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; Right)<span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> val &lt; Right.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DisSet</span> &#123;</span><br><span class="line">	<span class="type">int</span> Father[<span class="number">101</span>];</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp; F = Father[x];</span><br><span class="line">		<span class="keyword">return</span> x == F ? x : (F = <span class="built_in">find</span>(F));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//合并</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Edge&amp;edge)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Father[<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from)] = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否同一集合</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from) == <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;DSet;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; Edges;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Edges.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> from, to, val;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;val);</span><br><span class="line">		Edges.<span class="built_in">emplace_back</span>(from, to, val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> Ans = inf;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		DSet.<span class="built_in">init</span>(n);</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m; ++j) &#123;</span><br><span class="line">			<span class="type">const</span> Edge&amp; Cur = Edges[j];</span><br><span class="line">			<span class="keyword">if</span> (!DSet.<span class="built_in">query</span>(Cur)) &#123;</span><br><span class="line">				DSet.<span class="built_in">merge</span>(Cur);</span><br><span class="line">				++cnt;</span><br><span class="line">				<span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">					Ans = <span class="built_in">min</span>(Ans, Edges[j].val - Edges[i].val);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans == inf ? <span class="number">-1</span> : Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">if</span> (!m &amp;&amp; !n)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">input</span>();</span><br><span class="line">		<span class="built_in">sort</span>(Edges.<span class="built_in">begin</span>(), Edges.<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">getAns</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>时间复杂度：</strong>$O(m^2)$</p>
<hr>
<h3 id="Q4-Buy-or-Build"><a href="#Q4-Buy-or-Build" class="headerlink" title="Q4 Buy or Build"></a>Q4 Buy or Build</h3><p><a target="_blank" rel="noopener" href="https://vj.z180.cn/1085d5e20cb7a194741010c5ce76e0a4?v=1577193057">题目pdf</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem/B">题目链接</a><br><img src="https://img-blog.csdnimg.cn/20191228031226362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTcxNzk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>题目描述<br>万维网（WWN）是一家运营大型电信网络的领先公司。 WWN希望在Borduria建立一个新的网络，您需要帮助WWN确定如何以最低的总成本设置其网络。有几个本地公司运营着一些小型网络（以下称为子网），部分覆盖了Borduria的n个最大城市。 WWN希望建立一个连接所有n个城市的网络。 要实现这一目标，它可以从头开始在城市之间建设网络，也可以从本地公司购买一个或多个子网。 您需要帮助WWN决定如何以最低的总成本建设其网络。<br>1、所有n个城市都给出其二维坐标<br>2、存在q个子网。 如果$q≥1$,给出每个子网中连接的城市。（不用关心连接的形状）<br>3、每个子网只能购买，不能被分割<br>4、连接两个不相通的城市，必须建立一个边，其建设成本是城市之间欧几里德距离的平方。<br>您的任务是决定购买哪些现有网络以及建设哪些边，使得总成本最低。<br>输入格式<br>输入文件的第一行是一个整数T，表示测试数据的组数。接下来是一个空白行。每两组测试数据之间也有一个空白行。<br>对于每组测试数据：<br>第一行是两个整数，分别是城市的总数n和子网的数量q，1≤n≤1000，0≤q≤8。城/市的编号从1到n<br>接下来q行，每行多个整数，第一个整数表示这个子网中的城市的数量m，第二个整数表示购买这个子网的费用（费用不超过$2*10^6$），剩下的m个整数表示这个子网包含的城市<br>接下来n行，每行两个整数，表示第i个城市的坐标（坐标的数字范围是0到3000）<br>输出格式<br>对于每组测试数据输出一行，输出建设网络的总费用。每组输出之间用一个空行隔开<br>Translated by @kevensice__<br>引用自洛谷</p>
</blockquote>
<p>不购买子网络的情况，只要求相应的最小生成树就好了，记此时的最小生成树对应的边集合为$A$。而对于购买子网络的情况，显然此时的最优解中的边要么出现在子网络中，要么出现在$A$中。当我们购买子网络时，先将子网络中的边加入并查集，然后再在A中找边来生成最小生成树即可。（采用<em>Kruskal</em>算法）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">2000000000</span>;</span><br><span class="line"><span class="comment">//点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y, node;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y,<span class="type">int</span>&amp;node)</span> :x(x), y(y),node(node) &#123;</span>  &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getSquare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getDis</span><span class="params">(<span class="type">const</span> Node&amp; Right)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getSquare</span>(x - Right.x) + <span class="built_in">getSquare</span>(y - Right.y);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	<span class="type">int</span> dis;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">(<span class="type">const</span> Node&amp;Left, <span class="type">const</span> Node&amp; Right)</span> </span>&#123;</span><br><span class="line">		from = Left.node;</span><br><span class="line">		to = Right.node;</span><br><span class="line">		dis = Left.<span class="built_in">getDis</span>(Right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; Right)<span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dis &lt; Right.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子网络</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NetWork</span> &#123;</span><br><span class="line">	<span class="type">int</span> N, Cost;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; Has;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;Cost);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> point;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;point);</span><br><span class="line">			Has.<span class="built_in">push_back</span>(point);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DisSet</span> &#123;</span><br><span class="line">	<span class="type">int</span> Father[<span class="number">1001</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp; F = Father[x];</span><br><span class="line">		<span class="keyword">return</span> x == F ? x : (F = <span class="built_in">find</span>(F));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Edge&amp;edge)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Father[<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from)] = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> NetWork&amp; network)</span> </span>&#123;</span><br><span class="line">		<span class="type">const</span> <span class="keyword">auto</span>&amp; points = network.Has;</span><br><span class="line">		<span class="keyword">if</span> (points.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span>&amp; F = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(points.<span class="built_in">front</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(points[i])] = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(F);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from) == <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;DSet;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; Edges;</span><br><span class="line">vector&lt;Node&gt; nodes;</span><br><span class="line">vector&lt;NetWork&gt; networks;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	networks.<span class="built_in">clear</span>();</span><br><span class="line">	nodes.<span class="built_in">clear</span>();</span><br><span class="line">	networks.<span class="built_in">resize</span>(t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">		networks[i].<span class="built_in">input</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		nodes.<span class="built_in">emplace_back</span>(x, y, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将点装欢为边，没两点之间都生成一条边</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getEdge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Edges.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			Edges.<span class="built_in">emplace_back</span>(nodes[i], nodes[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Edge&gt;temp;<span class="comment">//用来保存最小生成树</span></span><br><span class="line">	<span class="type">int</span>&amp;&amp; cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>&amp;&amp; Ans = <span class="number">0</span>;</span><br><span class="line">	DSet.<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="built_in">sort</span>(Edges.<span class="built_in">begin</span>(), Edges.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : Edges) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DSet.<span class="built_in">query</span>(edge)) &#123;</span><br><span class="line">			DSet.<span class="built_in">merge</span>(edge);</span><br><span class="line">			++cnt;</span><br><span class="line">			Ans += edge.dis;</span><br><span class="line">			temp.<span class="built_in">push_back</span>(edge);</span><br><span class="line">			<span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">				Edges = temp;<span class="comment">//此时Edges为最小生成树</span></span><br><span class="line">				<span class="keyword">return</span> Ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Transver</span><span class="params">(vector&lt;Edge&gt;&amp; Edges)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp;&amp; Ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : Edges) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DSet.<span class="built_in">query</span>(edge)) &#123;</span><br><span class="line">			DSet.<span class="built_in">merge</span>(edge);</span><br><span class="line">			Ans += edge.dis;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);</span><br><span class="line">		<span class="built_in">input</span>();</span><br><span class="line">		<span class="built_in">getEdge</span>();</span><br><span class="line">		<span class="type">int</span>&amp;&amp; Ans = <span class="built_in">getMST</span>();</span><br><span class="line">		<span class="comment">//采用位运算枚举所有子网络的购买方式</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="number">1</span> &lt;&lt; t) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">			DSet.<span class="built_in">init</span>(n);</span><br><span class="line">			<span class="type">int</span>&amp;&amp; Cost = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>, j = i; j; j &gt;&gt;= <span class="number">1</span>, ++cnt) &#123;	</span><br><span class="line">				<span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="type">const</span> NetWork&amp; Cur = networks[cnt];</span><br><span class="line">					DSet.<span class="built_in">merge</span>(Cur);</span><br><span class="line">					Cost += Cur.Cost;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			Ans = <span class="built_in">min</span>(Ans, Cost + <span class="built_in">Transver</span>(Edges));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">		<span class="keyword">if</span> (T) &#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>时间复杂度：</strong>$O(2^q(n^2logn))$</p>
<hr>
<p><sup><a href="#fn_Q5" id="reffn_Q5">Q5</a></sup>:</p>
<h3 id="Q5-Qin-Shi-Huang’s-National-Road-System"><a href="#Q5-Qin-Shi-Huang’s-National-Road-System" class="headerlink" title="Q5 Qin Shi Huang’s National Road System"></a>Q5 Qin Shi Huang’s National Road System</h3><p><a target="_blank" rel="noopener" href="https://vj.z180.cn/4622772414da0c8bd8d745b4d1709c80?v=1577431012">题目pdf</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem/C">题目链接</a><br><img src="https://img-blog.csdnimg.cn/20191228031310489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTcxNzk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>题目大意：</strong> n个城市，需要修建一些道路使得任意两个城市联通，还可以修一条魔法道路， 不花钱， 设魔法路连接的城市的人口之和为A， 所有道路总长为B， 求A/B的最大值。<br>可以先求一遍最小生成树，然后枚举每一对点，求若将这两个点作为魔法道路的最小生成树，然后不断更新答案即可。<br>举个例子：<br>假如有${1,2,3,4,5}$，5个节点组成了下图的最小生成树。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1((1))---2((2))</span><br><span class="line">1((1))---3((3))</span><br><span class="line">3---4((4))</span><br><span class="line">3---5((5))</span><br></pre></td></tr></table></figure><br>假如在4，5之间修建魔法道路，那么此时会变成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1((1))---2((2))</span><br><span class="line">1((1))---3((3))</span><br><span class="line">3---4((4))</span><br><span class="line">4--0---5((5))</span><br><span class="line">3---5((5))</span><br></pre></td></tr></table></figure><br> 此时3，4，5形成了一个环。显然4，5之间的边权重为0，而此时要想重新形成最小生成树，就需要在环中去掉一条边，那自然是去掉权重最大的边了。由于新加的边权重为0，所以最大边只能出先在原最小生成树上。对于任意节点$i,j$，在最小生成树上只有唯一的互通路径，而最大边只能出现在路径上。因此，用最大边替换魔法道路得到的权值和是最小的，此时（$B=$原最小生成树权重和$-$最大边）。因此，先求出最小生成树后，在树上DFS求出任意两点间路径的最大边，在枚举每一对点即可。<br> 而若$i,j$在最小生成树上直接相连，例如在3，5之间修建魔法道路，会形成如图：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1((1))---2((2))</span><br><span class="line">1((1))---3((3))</span><br><span class="line">3---4((4))</span><br><span class="line">3--0---5((5))</span><br></pre></td></tr></table></figure><br>此时3，5之间的最大边唯一，将此边换成魔法道路,（B=原最小生成树权重和$-$最大边)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y, P, node;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y, <span class="type">int</span>&amp; P,<span class="type">int</span>&amp;node) :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">P</span>(P),<span class="built_in">node</span>(node) &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getSquare</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getDis</span><span class="params">(<span class="type">const</span> Node&amp; Right)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>(</span><br><span class="line">			<span class="built_in">getSquare</span>(x - Right.x) +</span><br><span class="line">			<span class="built_in">getSquare</span>(y - Right.y)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	<span class="type">double</span> dis;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">const</span> Node&amp; Left, <span class="type">const</span> Node&amp; Right) :<span class="built_in">from</span>(Left.node), <span class="built_in">to</span>(Right.node), <span class="built_in">dis</span>(Left.<span class="built_in">getDis</span>(Right)) &#123;  &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; Right)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dis &lt; Right.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> Father[<span class="number">1001</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp; F = <span class="keyword">this</span>-&gt;Father[x];</span><br><span class="line">		<span class="keyword">return</span> x == F ? x : (F = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(F));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Father[<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from)] = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from) == <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;DSet;</span><br><span class="line">vector&lt;Node&gt;nodes;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	nodes.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y, P, node;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;P);</span><br><span class="line">		nodes.<span class="built_in">emplace_back</span>(x, y, P, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将点转换为边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initEdge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nodes.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			edges.<span class="built_in">emplace_back</span>(nodes[i], nodes[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最小生成树</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Edge&gt;temp;</span><br><span class="line">	DSet.<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">stable_sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span>&amp;&amp; cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span>&amp;&amp; Ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DSet.<span class="built_in">query</span>(edge)) &#123;</span><br><span class="line">			DSet.<span class="built_in">merge</span>(edge);</span><br><span class="line">			++cnt;</span><br><span class="line">			temp.<span class="built_in">push_back</span>(edge);</span><br><span class="line">			Ans += edge.dis;</span><br><span class="line">			<span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">				edges = temp;</span><br><span class="line">				<span class="keyword">return</span> Ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> Dis[<span class="number">1001</span>][<span class="number">1001</span>];<span class="comment">//Dis[i][j]为i到j在最小生成树上的最大边</span></span><br><span class="line"><span class="type">bool</span> Vis[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="type">double</span> dis;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">int</span>&amp; cur,<span class="type">const</span> <span class="type">double</span>&amp; dis) :<span class="built_in">node</span>(cur), <span class="built_in">dis</span>(dis) &#123;  &#125;</span><br><span class="line">	<span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Point&gt;G[<span class="number">1001</span>];</span><br><span class="line"><span class="comment">//DFS计算Dis</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getDis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//G为邻接链表</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		G[i].<span class="built_in">clear</span>();</span><br><span class="line">		Vis[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//建表</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">		G[edge.from].<span class="built_in">emplace_back</span>(edge.to,edge.dis);</span><br><span class="line">		G[edge.to].<span class="built_in">emplace_back</span>(edge.from, edge.dis);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			Dis[i][j] = <span class="number">0.</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//DFS</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		stack&lt;Point&gt; S;</span><br><span class="line">		S.<span class="built_in">emplace</span>(i,<span class="number">0.</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			Vis[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			Point cur = S.<span class="built_in">top</span>();</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (Vis[cur.node])<span class="keyword">continue</span>;</span><br><span class="line">			Vis[cur.node] = <span class="literal">true</span>;</span><br><span class="line">			Dis[i][cur.node] = <span class="built_in">max</span>(Dis[i][cur.node], cur.dis);</span><br><span class="line">			Dis[cur.node][i] = <span class="built_in">max</span>(Dis[cur.node][i], cur.dis);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">const</span> Point&amp; Next : G[cur.node]) &#123;</span><br><span class="line">				S.<span class="built_in">emplace</span>(Next.node,<span class="built_in">max</span>(cur.dis,Next.dis));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">input</span>();</span><br><span class="line">		<span class="built_in">initEdge</span>();</span><br><span class="line">		<span class="type">double</span>&amp;&amp; W = <span class="built_in">getMST</span>();</span><br><span class="line">		<span class="built_in">getDis</span>();</span><br><span class="line">		<span class="type">double</span>&amp;&amp; Ans = <span class="number">0.</span>;</span><br><span class="line">		<span class="comment">//枚举计算最大的A/B</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				Ans = <span class="built_in">max</span>(Ans, <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(nodes[i].P + nodes[j].P) / (W-Dis[nodes[i].node][nodes[j].node]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, Ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>时间复杂度：</strong>$O(n^2)$</p>
<hr>
<h3 id="Q6-Edges-in-MST"><a href="#Q6-Edges-in-MST" class="headerlink" title="Q6 Edges in MST"></a>Q6 Edges in MST</h3><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem/D">题目链接</a></p>
<blockquote>
<p><strong>题目描述</strong><br>You are given a connected weighted undirected graph without any loops and multiple edges.Let us remind you that a graph’s spanning tree is defined as an acyclic connected subgraph of the given graph that includes all of the graph’s vertexes. The weight of a tree is defined as the sum of weights of the edges that the given tree contains. The minimum spanning tree (MST) of a graph is defined as the graph’s spanning tree having the minimum possible weight. For any connected graph obviously exists the minimum spanning tree, but in the general case, a graph’s minimum spanning tree is not unique.Your task is to determine the following for each edge of the given graph: whether it is either included in any MST, or included at least in one MST, or not included in any MST.<br><strong>输入格式</strong><br>The first line contains two integers  n and  m ( $2\leq n\leq 10^5$ , ) — the number of the graph’s vertexes and edges, correspondingly. Then follow m m m lines, each of them contains three integers — the description of the graph’s edges as “ $a<em>{i}b</em>{i}w<em>{i}​$ “ ( $1\leq a_i,b_i\leq n,1\leq w_i\leq 10^6,ai≠bi$ ), where $a</em>{i}$ and $b<em>{i}$ are the numbers of vertexes connected by the$i</em>{th}$ edge, $w<em>{i}$​ is the edge’s weight. It is guaranteed that the graph is connected and doesn’t contain loops or multiple edges.输出格式Print m m m lines — the answers for all edges. If the $i</em>{th}$ edge is included in any MST, print “any”; if the $i<em>{th}$ edge is included at least in one MST, print “at least one”; if the $i</em>{th}$ edge isn’t included in any MST, print “none”. Print the answers for the edges in the order in which the edges are specified in the input.<br><strong>题目大意:</strong><br>给一个带权的无向图,保证没有自环和重边. 由于最小生成树不唯一,因此你需要确定每一条边是以下三种情况哪一个 :<br>1.一定在所有MST上<br>2.可能在某个MST上<br>3.一定不可能在任何MST上<br>输入第一行给出n,m表示点数和边数. 数据范围见原题面 之后m行,每行给出ai,bi,wi 表示一个边的两个端点和边的权值.保证没有自环与重边. 输出你需要输出m行,每行依次表示输入的第几条边,如果是情况1,输出 “any”(不包含引号);如果是情况2,输出 “at least one”(不包含引号);如果是情况3,输出 “none”(不包含引号).<br><strong>输入输出样例</strong><br>输入<br> 4 5<br>1 2 101<br>1 3 100<br>2 3 2<br>2 4 2<br>3 4 1<br>输出<br> none<br>any<br>at least one<br>at least one<br>any<br>输入<br>3 3<br>1 2 1<br>2 3 1<br>1 3 2<br>输出<br> any<br>any<br>none<br>输入<br>3 3<br>1 2 1<br>2 3 1<br>1 3 1<br>输出<br> at least one<br>at least one<br>at least one<br><strong>说明/提示</strong><br>In the second sample the MST is unique for the given graph: it contains two first edges.In the third sample any two edges form the MST for the given graph. That means that each edge is included at least in one MST.</p>
</blockquote>
<p> 对于某条边，如果它权值大于最小生成树上的相应边，那就是<strong>none</strong>，如果它等于相应边并且是桥边，那就是<strong>any</strong>，不是桥边那就是<strong>at least one</strong>了。Tarjan找桥。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> Root[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> From, Index, Next;</span><br><span class="line">&#125;edges[MAXN];</span><br><span class="line"><span class="type">int</span> From[MAXN], To[MAXN], Cost[MAXN], Hash[MAXN];</span><br><span class="line"><span class="type">int</span> Ans[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, Len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> ind, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	edges[i].Next = Root[f];</span><br><span class="line">	Root[f] = i;</span><br><span class="line">	edges[i].From = t;</span><br><span class="line">	edges[i].Index = ind;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Father[MAXN], Counts[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Father[x] == x ? x : Father[x] = <span class="built_in">Find</span>(Father[x]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Find</span>(x) == <span class="built_in">Find</span>(y))<span class="keyword">return</span>;</span><br><span class="line">	Counts[<span class="built_in">Find</span>(y)] += Counts[<span class="built_in">Find</span>(x)];</span><br><span class="line">	Counts[<span class="built_in">Find</span>(x)] = <span class="number">0</span>;</span><br><span class="line">	Father[<span class="built_in">Find</span>(x)] = <span class="built_in">Find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DFN[MAXN], LOW[MAXN], Cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	DFN[s] = LOW[s] = ++Cnt;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> p = Root[s]; p != <span class="number">0</span>; p = edges[p].Next) &#123;</span><br><span class="line">		<span class="type">int</span> t = edges[p].From;</span><br><span class="line">		<span class="keyword">if</span> (p == (((f - <span class="number">1</span>) ^ <span class="number">1</span>) + <span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (DFN[t] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">DFS</span>(t, p);</span><br><span class="line">			<span class="keyword">if</span> (LOW[t] &gt; DFN[s]) &#123;</span><br><span class="line">				Ans[edges[p].Index] = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				LOW[s] = <span class="built_in">min</span>(LOW[s], LOW[t]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			LOW[s] = <span class="built_in">min</span>(LOW[s], DFN[t]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> STemp[MAXN], Tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(Hash, Hash + m,</span><br><span class="line">		[](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">bool</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> Cost[a] &lt; Cost[b]; </span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; Counts[<span class="built_in">Find</span>(<span class="number">1</span>)] &lt; n;) &#123;</span><br><span class="line">		<span class="type">int</span> j = i;</span><br><span class="line">		<span class="keyword">while</span> (Cost[Hash[i]] == Cost[Hash[j]] &amp;&amp; j &lt; m) &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">			<span class="type">int</span> Index = Hash[k];</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Find</span>(From[Index]) != <span class="built_in">Find</span>(To[Index])) &#123;</span><br><span class="line">				STemp[Tail++] = Index;</span><br><span class="line">				Ans[Index] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; Tail; p++) &#123;</span><br><span class="line">			<span class="type">int</span> tp = STemp[p];</span><br><span class="line">			<span class="type">int</span> f = <span class="built_in">Find</span>(From[tp]), t = <span class="built_in">Find</span>(To[tp]);</span><br><span class="line">			<span class="built_in">AddEdge</span>(f, t, tp, ++Len);</span><br><span class="line">			<span class="built_in">AddEdge</span>(t, f, tp, ++Len);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; Tail; p++) &#123;</span><br><span class="line">			<span class="type">int</span> tp = STemp[p];</span><br><span class="line">			<span class="type">int</span> f = <span class="built_in">Find</span>(From[tp]), t = <span class="built_in">Find</span>(To[tp]);</span><br><span class="line">			<span class="built_in">DFS</span>(f, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">Merge</span>(f, t);</span><br><span class="line">		&#125;</span><br><span class="line">		Cnt = <span class="number">0</span>;</span><br><span class="line">		Len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; Tail; p++) &#123;</span><br><span class="line">			<span class="type">int</span> tp = STemp[p];</span><br><span class="line">			<span class="type">int</span> f = <span class="built_in">Find</span>(From[tp]), t = <span class="built_in">Find</span>(To[tp]);</span><br><span class="line">			Root[f] = Root[t] = <span class="number">0</span>;</span><br><span class="line">			DFN[f] = DFN[t] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i = j;</span><br><span class="line">		Tail = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		Father[i] = i; Counts[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, From + i, To + i, Cost + i);</span><br><span class="line">		Hash[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (Ans[i]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;any&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;at least one&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>: &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;none&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Input</span>();</span><br><span class="line">	<span class="built_in">Compute</span>();</span><br><span class="line">	<span class="built_in">Output</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Q7-ACM-Contest-and-Blackout"><a href="#Q7-ACM-Contest-and-Blackout" class="headerlink" title="Q7 ACM Contest and Blackout"></a>Q7 ACM Contest and Blackout</h3><p><a target="_blank" rel="noopener" href="https://vj.z180.cn/d160747c5eeea750b7a493d05bbad9da?v=1577011092">题目pdf</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem/E">题目链接</a><br><img src="https://img-blog.csdnimg.cn/20191228031442661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTcxNzk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>题目要求非严格次小生成树。<br>次小生成树和最小生成树一定只有一条边不同，即将最小生成树的其中一条边替换掉。<br>和<strong>Q5</strong>类似，先求最小生成树，再遍历所有不在最小生树中的边，将其替换即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to, weight;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; from, <span class="type">const</span> <span class="type">int</span>&amp; to, <span class="type">const</span> <span class="type">int</span>&amp; weight)</span><span class="keyword">noexcept</span> :from(from), to(to), weight(weight) &#123;</span>  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">()</span><span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; Right)<span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight &lt; Right.weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> Father[<span class="number">101</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp; F = <span class="keyword">this</span>-&gt;Father[x];</span><br><span class="line">		<span class="keyword">return</span> x == F ? x : (F = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(F));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Father[<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from)] = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from) == <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;DSet;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;Edge&gt; MST;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	edges.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> from, to, weight;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;weight);</span><br><span class="line">		edges.<span class="built_in">emplace_back</span>(from, to, weight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getMST</span><span class="params">()</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">	MST.<span class="built_in">clear</span>();</span><br><span class="line">	DSet.<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="type">int</span></span><br><span class="line">		&amp;&amp; Ans = <span class="number">0</span>,</span><br><span class="line">		&amp;&amp; Cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = edges.<span class="built_in">cbegin</span>(); it != edges.<span class="built_in">cend</span>();) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DSet.<span class="built_in">query</span>(*it)) &#123;</span><br><span class="line">			DSet.<span class="built_in">merge</span>(*it);</span><br><span class="line">			++Cnt;</span><br><span class="line">			Ans += it-&gt;weight;</span><br><span class="line">			MST.<span class="built_in">emplace_back</span>(*it);</span><br><span class="line">			it = edges.<span class="built_in">erase</span>(it);</span><br><span class="line">			<span class="keyword">if</span> (Cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> Ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="type">int</span> node, weight;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; to, <span class="type">const</span> <span class="type">int</span>&amp; weight)</span><span class="keyword">noexcept</span> :node(to), weight(weight) &#123;</span>  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">()</span><span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Point&gt; G[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> Dis[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">bool</span> Vis[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">initDis</span><span class="params">()</span><span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(Dis, <span class="number">0x0</span>, <span class="built_in">sizeof</span>(Dis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		G[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : MST) &#123;</span><br><span class="line">		G[edge.from].<span class="built_in">emplace_back</span>(edge.to, edge.weight);</span><br><span class="line">		G[edge.to].<span class="built_in">emplace_back</span>(edge.from, edge.weight);</span><br><span class="line">	&#125;</span><br><span class="line">	stack&lt;Point&gt; S;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		S.<span class="built_in">emplace</span>(i,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memset</span>(Vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(Vis));</span><br><span class="line">		<span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			Point Cur = S.<span class="built_in">top</span>();</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (Vis[Cur.node])<span class="keyword">continue</span>;</span><br><span class="line">			Vis[Cur.node] = <span class="literal">true</span>;</span><br><span class="line">			Dis[i][Cur.node] = <span class="built_in">max</span>(Dis[i][Cur.node], Cur.weight);</span><br><span class="line">			Dis[Cur.node][i] = <span class="built_in">max</span>(Dis[Cur.node][i], Cur.weight);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">const</span> Point&amp; Next : G[Cur.node]) &#123;</span><br><span class="line">				S.<span class="built_in">emplace</span>(Next.node, <span class="built_in">max</span>(Next.weight, Cur.weight));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getSMST</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;MSTValue)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp;&amp; Ans = <span class="number">2000000000</span>;</span><br><span class="line">	<span class="built_in">initDis</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = edges.<span class="built_in">cbegin</span>(); it != edges.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">		Ans = <span class="built_in">min</span>(Ans, it-&gt;weight - Dis[it-&gt;from][it-&gt;to]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> MSTValue + Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">input</span>();</span><br><span class="line">		<span class="type">int</span>&amp;&amp; Ans1 = <span class="built_in">getMST</span>();</span><br><span class="line">		<span class="type">int</span>&amp;&amp; Ans2 = <span class="built_in">getSMST</span>(Ans1);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, Ans1, Ans2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(n^2logn)$</p>
<hr>
<h3 id="Q8-Arctic-Network"><a href="#Q8-Arctic-Network" class="headerlink" title="Q8 Arctic Network"></a>Q8 Arctic Network</h3><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem/F">题目链接</a></p>
<blockquote>
<p>The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network. Two different communication technologies are to be used in establishing the network: every outpost will have a radio transceiver and some outposts will in addition have a satellite channel.<br>       Any two outposts with a satellite channel can communicate via the satellite, regardless of their location. Otherwise, two outposts can communicate by radio only if the distance between them does not exceed D, which depends of the power of the transceivers. Higher power yields higher D but costs more. Due to purchasing and maintenance considerations, the transceivers at the outposts must be identical; that is, the value of D is the same for every pair of outposts.<br>       Your job is to determine the minimum D required for the transceivers. There must be at least one communication path (direct or indirect) between every pair of outposts.<br>Input<br>The first line of input contains N, the number of test cases. The first line of each test case contains 1 &lt;= S &lt;= 100, the number of satellite channels, and S &lt; P &lt;= 500, the number of outposts. P lines follow, giving the (x,y) coordinates of each outpost in km (coordinates are integers between 0 and 10,000).<br>Output<br>For each case, output should consist of a single line giving the minimum D required to connect the network. Output should be specified to 2 decimal points.<br>Sample Input<br>        1<br>2 4<br>0 100<br>0 300<br>0 600<br>150 750<br>Sample Output<br>        212.13</p>
</blockquote>
<p><strong>题目大意：</strong><br>给出一张图，求该图的最小瓶颈生成树。<br><strong>瓶颈生成树：</strong><br>无向图$G$的一颗瓶颈生成树是这样的一颗生成树：它最大的边权值在$G$的所有生成树中是最小的。瓶颈生成树的值为T中最大权值边的权。<br>该图建立在坐标系中， 给出每个点的坐标。任意两点之间都有边，边权即为两点间的距离。</p>
<p>瓶颈生成树就是最小生成树，因为在树中每两个点之间只有一条边，所以最小生成树就是选择两点间最短的边，而瓶颈生成树同样也是取最小边。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y, node;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> <span class="type">int</span>&amp; node) :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">node</span>(node) &#123;  &#125;</span><br><span class="line">	<span class="built_in">Point</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getSquare</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getDis</span><span class="params">(<span class="type">const</span> Point&amp; Right)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>(</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">getSquare</span>(x - Right.x) +</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">getSquare</span>(y - Right.y)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	<span class="type">double</span> weight;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; from, <span class="type">const</span> <span class="type">int</span>&amp; to, <span class="type">const</span> <span class="type">int</span>&amp; weight)</span> :from(from), to(to), weight(weight) &#123;</span>  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; Right)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight &lt; Right.weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">(<span class="type">const</span> Point&amp; Left, <span class="type">const</span> Point&amp; Right)</span> :from(Left.node), to(Right.node), weight(Left.getDis(Right)) &#123;</span>  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> Father[<span class="number">501</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp; F = <span class="keyword">this</span>-&gt;Father[x];</span><br><span class="line">		<span class="keyword">return</span> x == F ? x : (F = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(F));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Father[<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from)] = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from) == <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;DSet;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;Edge&gt; MST;</span><br><span class="line">vector&lt;Point&gt;points;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">	edges.<span class="built_in">clear</span>();</span><br><span class="line">	points.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(x, y, i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(points[i], points[j]));</span><br><span class="line">			edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(points[j], points[i]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">getCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">	MST.<span class="built_in">clear</span>();</span><br><span class="line">	DSet.<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="type">int</span> Cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Edge&gt;::iterator it = edges.<span class="built_in">begin</span>(); it != edges.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DSet.<span class="built_in">query</span>(*it)) &#123;</span><br><span class="line">			DSet.<span class="built_in">merge</span>(*it);</span><br><span class="line">			++Cnt;</span><br><span class="line">			MST.<span class="built_in">push_back</span>(*it);</span><br><span class="line">			<span class="keyword">if</span> (Cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> MST[n - <span class="number">1</span> - k].weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">input</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, <span class="built_in">getCost</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(n^2logn)$</p>
<hr>
<h3 id="Q9-Conquer-a-New-Region"><a href="#Q9-Conquer-a-New-Region" class="headerlink" title="Q9 Conquer a New Region"></a>Q9 Conquer a New Region</h3><p> <a target="_blank" rel="noopener" href="https://vj.z180.cn/6d33dd16af564c3f7299e67393df3b1e?v=1577220614">题目pdf</a><br> <a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem/G">题目链接</a><br> <img src="https://img-blog.csdnimg.cn/20191228031545154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTcxNzk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>题目大意：<br>有N个城镇(编号从1到N)，由几条公路连接起来。任何两个城镇之间都有一条确切的路线。我们定义道路的容量C(i，j)，表示允许最多C(i，j)货物在镇i和镇j之间运输。如果镇 i 和 镇 j 之间有道路连通的话，我们定义了一个值S(i，j)，它表示i和j之间唯一通路上容量的最小值。我们的国王想要选择一个中心城市来恢复他的战争资源。使中心到其他 N−1 个城镇交通能力（即到其他所有点的容量之和）最大化。现在，你，这个王国里最好的程序员，应该能帮助我们的国王选择这个中心。<br>简述：<br>假设 N （N &lt;= 200000） 个城市形成一棵树，每条边有权值 C（i，j）。任意两个点的容量 S （i ，j）定义为 i 与 j 唯一通路上容量的最小值。找一个点（它将成为中心城市），使得它到其他所有点的容量之和最大。<br>输入：<br>有多个测试样例。<br>每一种情况下第一行一个整数 N  (1 ≤ N ≤ 200, 000)<br>之后 N-1 行 每行包含三个整数 A , B , C ,表明 A 城和 B 城之间有一条容量为 C 的道路。 (1 ≤ a, b ≤ N, 1 ≤ c ≤ 100, 000)<br>输出：<br>对于每个测试用例，输出一个整数，表示所选择的中心城镇的总交通容量。<br>翻译来自洛谷</p>
</blockquote>
<p>在树中，每一条边都是桥边。<br>假设对于生成树${1,2,3,4,5,6}$，设集合$A={1,2,3}$，集合$B={4,5,6}$，此时要将$A,B$合并。记$F(x)$为以$x$作为中心的总容量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1((1))---3((3))</span><br><span class="line">2((2))---3((3))</span><br><span class="line">4((4))---5((5))</span><br><span class="line">4---6((6))</span><br></pre></td></tr></table></figure><br>可以看到，若将$A,B$合并，则A中的点到B必定经过$E<em>{34}$，B同理。若$E</em>{34}$比$A,B$中的权值都小，那么(合并后的$F(A)=$合并前的$F(A)+B$中点的数量$<em>E<em>{34}$的权值)。$B$同理。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1((1))---3((3))</span><br><span class="line">2((2))---3((3))</span><br><span class="line">3--E_34---4((4))</span><br><span class="line">4---5((5))</span><br><span class="line">4---6((6))</span><br></pre></td></tr></table></figure><br>所以为了保证$E</em>{34}$是最小的，在合并生成树前，我们将边按<strong>从大到小</strong>排序。然后在比较$A,B$哪个作为中心容量和更大，哪个就作为生成树的父节点，即作为中心城市。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y, P, node;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y, <span class="type">int</span>&amp; P,<span class="type">int</span>&amp;node) :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">P</span>(P),<span class="built_in">node</span>(node) &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">getSquare</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getDis</span><span class="params">(<span class="type">const</span> Node&amp; Right)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>(</span><br><span class="line">			<span class="built_in">getSquare</span>(x - Right.x) +</span><br><span class="line">			<span class="built_in">getSquare</span>(y - Right.y)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	<span class="type">int</span> dis;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span>&amp; from, <span class="type">int</span>&amp; to, <span class="type">int</span>&amp; dis) :<span class="built_in">from</span>(from), <span class="built_in">to</span>(to), <span class="built_in">dis</span>(dis) &#123;  &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; Right)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dis &gt; Right.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> Father[<span class="number">200001</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp; F = <span class="keyword">this</span>-&gt;Father[x];</span><br><span class="line">		<span class="keyword">return</span> x == F ? x : (F = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(F));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Father[<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from)] = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from) == <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;DSet;</span><br><span class="line">vector&lt;Node&gt;nodes;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line"><span class="type">int</span> Ans[<span class="number">200001</span>],<span class="comment">//Ans[i]表示当前以i点为中心的容量和</span></span><br><span class="line"> Cnt[<span class="number">200001</span>];<span class="comment">//Cnt[i]表示i点所在的集合的点的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> from, to, val;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;from, &amp;to, &amp;val);</span><br><span class="line">		edges.<span class="built_in">emplace_back</span>(from, to, val);</span><br><span class="line">		Ans[i] = <span class="number">0</span>;</span><br><span class="line">		Cnt[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Cnt[n] = <span class="number">1</span>;</span><br><span class="line">	Ans[n] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n)) &#123;</span><br><span class="line">		<span class="built_in">input</span>();</span><br><span class="line">		<span class="built_in">stable_sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">		DSet.<span class="built_in">init</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">			<span class="type">int</span> fx = DSet.<span class="built_in">find</span>(edge.from);</span><br><span class="line">			<span class="type">int</span> fy = DSet.<span class="built_in">find</span>(edge.to);</span><br><span class="line">			<span class="comment">//容量和大的作为中心，作为父节点</span></span><br><span class="line">			<span class="keyword">if</span> (fx != fy)&#123;</span><br><span class="line">				<span class="keyword">if</span> (Ans[fy] + Cnt[fx] * edge.dis &gt; Ans[fx] + Cnt[fy] * edge.dis) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(fx, fy);</span><br><span class="line">				&#125;</span><br><span class="line">				Ans[fx] += Cnt[fy] * edge.dis;</span><br><span class="line">				DSet.Father[fy] = fx;</span><br><span class="line">				Cnt[fx] += Cnt[fy];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans[DSet.<span class="built_in">find</span>(<span class="number">1</span>)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><em>*时间复杂度</em></em>：$O(n^2logn)$</p>
<hr>
<h3 id="Q10-Bond"><a href="#Q10-Bond" class="headerlink" title="Q10 Bond"></a>Q10 Bond</h3><p><a target="_blank" rel="noopener" href="https://vj.z180.cn/4d36de8ccdf7f5f3287712a350f6e782?v=1577203737">题目pdf</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/349172#problem/H">题目链接</a><br><img src="https://img-blog.csdnimg.cn/20191228031623532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTcxNzk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>题目大意：</strong>求两点间最短路中的最大边。<br>用<em>Kruskal</em>算法求最小生成树（并查集不要路径压缩，保留树结构），然后遍历两点间的树上唯一路径找最大边即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to, weight;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; from, <span class="type">const</span> <span class="type">int</span>&amp; to, <span class="type">const</span> <span class="type">int</span>&amp; weight)</span> :from(from), to(to), weight(weight) &#123;</span>  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Edge</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; Right)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight &lt; Right.weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> Father[<span class="number">50001</span>];</span><br><span class="line">	<span class="type">int</span> Weight[<span class="number">50001</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Father[i] = i;</span><br><span class="line">			<span class="keyword">this</span>-&gt;Weight[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp; F = <span class="keyword">this</span>-&gt;Father[x];</span><br><span class="line">		<span class="keyword">return</span> x == F ? x : (<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(F));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>&amp;&amp; fx = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from);</span><br><span class="line">		<span class="type">int</span>&amp;&amp; fy = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">		<span class="keyword">this</span>-&gt;Father[fx] = fy;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Weight[fx] = <span class="built_in">max</span>(edge.weight, <span class="keyword">this</span>-&gt;Weight[fx]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">const</span> Edge&amp; edge)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.from) == <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(edge.to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;DSet;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp;&amp; Cnt = <span class="number">0</span>;</span><br><span class="line">	DSet.<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DSet.<span class="built_in">query</span>(edge)) &#123;</span><br><span class="line">			++Cnt;</span><br><span class="line">			DSet.<span class="built_in">merge</span>(edge);</span><br><span class="line">			<span class="keyword">if</span> (Cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> from, to, weight;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;weight);</span><br><span class="line">		edges.<span class="built_in">emplace_back</span>(from, to, weight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(temp, <span class="number">0x0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>, ans1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		temp[x] = ans;</span><br><span class="line">		<span class="keyword">if</span> (DSet.Father[x] == x) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, DSet.Weight[x]);</span><br><span class="line">		x = DSet.Father[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp[y]) &#123;</span><br><span class="line">			ans1 = <span class="built_in">max</span>(ans1, temp[y]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (DSet.Father[y] == y) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans1 = <span class="built_in">max</span>(ans1, DSet.Weight[y]);</span><br><span class="line">			y = DSet.Father[y];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fuck = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">		<span class="built_in">input</span>();</span><br><span class="line">		<span class="built_in">getMST</span>();</span><br><span class="line">		<span class="type">int</span> Q;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q);</span><br><span class="line">		<span class="keyword">if</span> (fuck++) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">			<span class="type">int</span> x, y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>(x, y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(N^2logN+QlogN)$</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="/about/">Xiao Luo.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/10/Algorithm/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">http://example.com/2022/12/10/Algorithm/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="/img/68.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/10/Algorithm/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B1%82%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"><img class="prev-cover" src="/img/69.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">学习笔记——求最大回文子串</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/10/Algorithm/%E6%95%B0%E5%AD%97%E5%AD%90%E4%B8%B2%E7%9A%84%E5%92%8C%20str2int/"><img class="next-cover" src="/img/75.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">数字子串的和 str2int</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/12/10/Algorithm/A%20Research%20Problem%EF%BC%88%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%8CDFS%EF%BC%89/" title="A Research Problem（欧拉函数，DFS）"><img class="cover" src="/img/4.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-10</div><div class="title">A Research Problem（欧拉函数，DFS）</div></div></a></div><div><a href="/2022/12/10/Algorithm/Almost%20Prime%20Numbers%EF%BC%88%E7%B4%A0%E6%95%B0%E7%AD%9B%EF%BC%89/" title="Almost Prime Numbers（素数筛）"><img class="cover" src="/img/6.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-10</div><div class="title">Almost Prime Numbers（素数筛）</div></div></a></div><div><a href="/2022/12/10/Algorithm/A%20Spy%20in%20the%20Metro/" title="A Spy in the Metro"><img class="cover" src="/img/5.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-10</div><div class="title">A Spy in the Metro</div></div></a></div><div><a href="/2022/12/10/Algorithm/And%20Then%20There%20Was%20One/" title="And Then There Was One"><img class="cover" src="/img/7.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-10</div><div class="title">And Then There Was One</div></div></a></div><div><a href="/2022/12/10/Algorithm/Books/" title="Books"><img class="cover" src="/img/10.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-10</div><div class="title">Books</div></div></a></div><div><a href="/2022/12/10/Algorithm/Another%20Crisis/" title="Another Crisis"><img class="cover" src="/img/8.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-10</div><div class="title">Another Crisis</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xiao Luo.</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/luoxiao23333"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/luoxiao23333" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luo.1632@osu.edu" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.linkedin.com/in/xiao-l-0489191a4/" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">Prim算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%E6%9C%80%E7%9F%AD%E7%BD%91%E7%BB%9C"><span class="toc-number">2.2.</span> <span class="toc-text">Q1最短网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">Kruskal算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">3.1.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8F%96%E8%88%8D"><span class="toc-number">4.</span> <span class="toc-text">二者取舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%E5%85%AC%E8%B7%AF%E4%BF%AE%E5%BB%BA"><span class="toc-number">4.1.</span> <span class="toc-text">Q2公路修建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3-Slim-Span%EF%BC%88%E8%8B%97%E6%9D%A1%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">Q3 Slim Span（苗条生成树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4-Buy-or-Build"><span class="toc-number">4.3.</span> <span class="toc-text">Q4 Buy or Build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5-Qin-Shi-Huang%E2%80%99s-National-Road-System"><span class="toc-number">4.4.</span> <span class="toc-text">Q5 Qin Shi Huang’s National Road System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6-Edges-in-MST"><span class="toc-number">4.5.</span> <span class="toc-text">Q6 Edges in MST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7-ACM-Contest-and-Blackout"><span class="toc-number">4.6.</span> <span class="toc-text">Q7 ACM Contest and Blackout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8-Arctic-Network"><span class="toc-number">4.7.</span> <span class="toc-text">Q8 Arctic Network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9-Conquer-a-New-Region"><span class="toc-number">4.8.</span> <span class="toc-text">Q9 Conquer a New Region</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10-Bond"><span class="toc-number">4.9.</span> <span class="toc-text">Q10 Bond</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/10/Course%20Note/NYU/DS-GA-1003%20Lab1%20Linear%20Descent,%20SGD,%20and%20Regularization/" title="DS-GA-1003 Lab1 Linear Descent, SGD, and Regularization"><img src="/img/2.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DS-GA-1003 Lab1 Linear Descent, SGD, and Regularization"/></a><div class="content"><a class="title" href="/2022/12/10/Course%20Note/NYU/DS-GA-1003%20Lab1%20Linear%20Descent,%20SGD,%20and%20Regularization/" title="DS-GA-1003 Lab1 Linear Descent, SGD, and Regularization">DS-GA-1003 Lab1 Linear Descent, SGD, and Regularization</a><time datetime="2022-12-11T02:03:25.000Z" title="Created 2022-12-10 21:03:25">2022-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/10/Algorithm/A%20Research%20Problem%EF%BC%88%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%8CDFS%EF%BC%89/" title="A Research Problem（欧拉函数，DFS）"><img src="/img/4.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A Research Problem（欧拉函数，DFS）"/></a><div class="content"><a class="title" href="/2022/12/10/Algorithm/A%20Research%20Problem%EF%BC%88%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%8CDFS%EF%BC%89/" title="A Research Problem（欧拉函数，DFS）">A Research Problem（欧拉函数，DFS）</a><time datetime="2022-12-11T02:03:25.000Z" title="Created 2022-12-10 21:03:25">2022-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/10/Algorithm/Almost%20Prime%20Numbers%EF%BC%88%E7%B4%A0%E6%95%B0%E7%AD%9B%EF%BC%89/" title="Almost Prime Numbers（素数筛）"><img src="/img/6.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Almost Prime Numbers（素数筛）"/></a><div class="content"><a class="title" href="/2022/12/10/Algorithm/Almost%20Prime%20Numbers%EF%BC%88%E7%B4%A0%E6%95%B0%E7%AD%9B%EF%BC%89/" title="Almost Prime Numbers（素数筛）">Almost Prime Numbers（素数筛）</a><time datetime="2022-12-11T02:03:25.000Z" title="Created 2022-12-10 21:03:25">2022-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/10/Algorithm/A%20Spy%20in%20the%20Metro/" title="A Spy in the Metro"><img src="/img/5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A Spy in the Metro"/></a><div class="content"><a class="title" href="/2022/12/10/Algorithm/A%20Spy%20in%20the%20Metro/" title="A Spy in the Metro">A Spy in the Metro</a><time datetime="2022-12-11T02:03:25.000Z" title="Created 2022-12-10 21:03:25">2022-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/10/Algorithm/And%20Then%20There%20Was%20One/" title="And Then There Was One"><img src="/img/7.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="And Then There Was One"/></a><div class="content"><a class="title" href="/2022/12/10/Algorithm/And%20Then%20There%20Was%20One/" title="And Then There Was One">And Then There Was One</a><time datetime="2022-12-11T02:03:25.000Z" title="Created 2022-12-10 21:03:25">2022-12-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Xiao Luo.</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div></div></body></html>